// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package databricks

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// > **Private Preview** This feature is in [Private Preview](https://docs.databricks.com/release-notes/release-types.html). Contact your Databricks representative to request access.
//
// A metastore is the top-level container of objects in Unity Catalog. It stores data assets (tables and views) and the permissions that govern access to them. Databricks account admins can create metastores and assign them to Databricks workspaces in order to control which workloads use each metastore.
//
// Unity Catalog offers a new metastore with built in security and auditing. This is distinct to the metastore used in previous versions of Databricks (based on the Hive Metastore).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"fmt"
//
// 	"github.com/paiyar/pulumi-databricks/sdk/go/databricks"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		thisMetastore, err := databricks.NewMetastore(ctx, "thisMetastore", &databricks.MetastoreArgs{
// 			StorageRoot:  pulumi.String(fmt.Sprintf("%v%v%v", "s3://", aws_s3_bucket.Metastore.Id, "/metastore")),
// 			Owner:        pulumi.String("uc admins"),
// 			ForceDestroy: pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = databricks.NewMetastoreAssignment(ctx, "thisMetastoreAssignment", &databricks.MetastoreAssignmentArgs{
// 			MetastoreId: thisMetastore.ID(),
// 			WorkspaceId: pulumi.Any(local.Workspace_id),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// This resource can be imported by IDbash
//
// ```sh
//  $ pulumi import databricks:index/metastore:Metastore this <id>
// ```
type Metastore struct {
	pulumi.CustomResourceState

	DefaultDataAccessConfigId pulumi.StringPtrOutput `pulumi:"defaultDataAccessConfigId"`
	// Destroy metastore regardless of its contents.
	ForceDestroy pulumi.BoolPtrOutput `pulumi:"forceDestroy"`
	// Name of metastore.
	Name pulumi.StringOutput `pulumi:"name"`
	// Username/groupname of Metastore owner.
	Owner pulumi.StringOutput `pulumi:"owner"`
	// Path on cloud storage account, where managed Table are stored. Change forces creation of a new resource.
	StorageRoot pulumi.StringOutput `pulumi:"storageRoot"`
}

// NewMetastore registers a new resource with the given unique name, arguments, and options.
func NewMetastore(ctx *pulumi.Context,
	name string, args *MetastoreArgs, opts ...pulumi.ResourceOption) (*Metastore, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.StorageRoot == nil {
		return nil, errors.New("invalid value for required argument 'StorageRoot'")
	}
	var resource Metastore
	err := ctx.RegisterResource("databricks:index/metastore:Metastore", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMetastore gets an existing Metastore resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMetastore(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MetastoreState, opts ...pulumi.ResourceOption) (*Metastore, error) {
	var resource Metastore
	err := ctx.ReadResource("databricks:index/metastore:Metastore", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Metastore resources.
type metastoreState struct {
	DefaultDataAccessConfigId *string `pulumi:"defaultDataAccessConfigId"`
	// Destroy metastore regardless of its contents.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// Name of metastore.
	Name *string `pulumi:"name"`
	// Username/groupname of Metastore owner.
	Owner *string `pulumi:"owner"`
	// Path on cloud storage account, where managed Table are stored. Change forces creation of a new resource.
	StorageRoot *string `pulumi:"storageRoot"`
}

type MetastoreState struct {
	DefaultDataAccessConfigId pulumi.StringPtrInput
	// Destroy metastore regardless of its contents.
	ForceDestroy pulumi.BoolPtrInput
	// Name of metastore.
	Name pulumi.StringPtrInput
	// Username/groupname of Metastore owner.
	Owner pulumi.StringPtrInput
	// Path on cloud storage account, where managed Table are stored. Change forces creation of a new resource.
	StorageRoot pulumi.StringPtrInput
}

func (MetastoreState) ElementType() reflect.Type {
	return reflect.TypeOf((*metastoreState)(nil)).Elem()
}

type metastoreArgs struct {
	DefaultDataAccessConfigId *string `pulumi:"defaultDataAccessConfigId"`
	// Destroy metastore regardless of its contents.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// Name of metastore.
	Name *string `pulumi:"name"`
	// Username/groupname of Metastore owner.
	Owner *string `pulumi:"owner"`
	// Path on cloud storage account, where managed Table are stored. Change forces creation of a new resource.
	StorageRoot string `pulumi:"storageRoot"`
}

// The set of arguments for constructing a Metastore resource.
type MetastoreArgs struct {
	DefaultDataAccessConfigId pulumi.StringPtrInput
	// Destroy metastore regardless of its contents.
	ForceDestroy pulumi.BoolPtrInput
	// Name of metastore.
	Name pulumi.StringPtrInput
	// Username/groupname of Metastore owner.
	Owner pulumi.StringPtrInput
	// Path on cloud storage account, where managed Table are stored. Change forces creation of a new resource.
	StorageRoot pulumi.StringInput
}

func (MetastoreArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metastoreArgs)(nil)).Elem()
}

type MetastoreInput interface {
	pulumi.Input

	ToMetastoreOutput() MetastoreOutput
	ToMetastoreOutputWithContext(ctx context.Context) MetastoreOutput
}

func (*Metastore) ElementType() reflect.Type {
	return reflect.TypeOf((**Metastore)(nil)).Elem()
}

func (i *Metastore) ToMetastoreOutput() MetastoreOutput {
	return i.ToMetastoreOutputWithContext(context.Background())
}

func (i *Metastore) ToMetastoreOutputWithContext(ctx context.Context) MetastoreOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetastoreOutput)
}

// MetastoreArrayInput is an input type that accepts MetastoreArray and MetastoreArrayOutput values.
// You can construct a concrete instance of `MetastoreArrayInput` via:
//
//          MetastoreArray{ MetastoreArgs{...} }
type MetastoreArrayInput interface {
	pulumi.Input

	ToMetastoreArrayOutput() MetastoreArrayOutput
	ToMetastoreArrayOutputWithContext(context.Context) MetastoreArrayOutput
}

type MetastoreArray []MetastoreInput

func (MetastoreArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Metastore)(nil)).Elem()
}

func (i MetastoreArray) ToMetastoreArrayOutput() MetastoreArrayOutput {
	return i.ToMetastoreArrayOutputWithContext(context.Background())
}

func (i MetastoreArray) ToMetastoreArrayOutputWithContext(ctx context.Context) MetastoreArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetastoreArrayOutput)
}

// MetastoreMapInput is an input type that accepts MetastoreMap and MetastoreMapOutput values.
// You can construct a concrete instance of `MetastoreMapInput` via:
//
//          MetastoreMap{ "key": MetastoreArgs{...} }
type MetastoreMapInput interface {
	pulumi.Input

	ToMetastoreMapOutput() MetastoreMapOutput
	ToMetastoreMapOutputWithContext(context.Context) MetastoreMapOutput
}

type MetastoreMap map[string]MetastoreInput

func (MetastoreMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Metastore)(nil)).Elem()
}

func (i MetastoreMap) ToMetastoreMapOutput() MetastoreMapOutput {
	return i.ToMetastoreMapOutputWithContext(context.Background())
}

func (i MetastoreMap) ToMetastoreMapOutputWithContext(ctx context.Context) MetastoreMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetastoreMapOutput)
}

type MetastoreOutput struct{ *pulumi.OutputState }

func (MetastoreOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Metastore)(nil)).Elem()
}

func (o MetastoreOutput) ToMetastoreOutput() MetastoreOutput {
	return o
}

func (o MetastoreOutput) ToMetastoreOutputWithContext(ctx context.Context) MetastoreOutput {
	return o
}

type MetastoreArrayOutput struct{ *pulumi.OutputState }

func (MetastoreArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Metastore)(nil)).Elem()
}

func (o MetastoreArrayOutput) ToMetastoreArrayOutput() MetastoreArrayOutput {
	return o
}

func (o MetastoreArrayOutput) ToMetastoreArrayOutputWithContext(ctx context.Context) MetastoreArrayOutput {
	return o
}

func (o MetastoreArrayOutput) Index(i pulumi.IntInput) MetastoreOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Metastore {
		return vs[0].([]*Metastore)[vs[1].(int)]
	}).(MetastoreOutput)
}

type MetastoreMapOutput struct{ *pulumi.OutputState }

func (MetastoreMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Metastore)(nil)).Elem()
}

func (o MetastoreMapOutput) ToMetastoreMapOutput() MetastoreMapOutput {
	return o
}

func (o MetastoreMapOutput) ToMetastoreMapOutputWithContext(ctx context.Context) MetastoreMapOutput {
	return o
}

func (o MetastoreMapOutput) MapIndex(k pulumi.StringInput) MetastoreOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Metastore {
		return vs[0].(map[string]*Metastore)[vs[1].(string)]
	}).(MetastoreOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MetastoreInput)(nil)).Elem(), &Metastore{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetastoreArrayInput)(nil)).Elem(), MetastoreArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetastoreMapInput)(nil)).Elem(), MetastoreMap{})
	pulumi.RegisterOutputType(MetastoreOutput{})
	pulumi.RegisterOutputType(MetastoreArrayOutput{})
	pulumi.RegisterOutputType(MetastoreMapOutput{})
}
